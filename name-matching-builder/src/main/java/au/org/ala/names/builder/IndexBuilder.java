package au.org.ala.names.builder;

import au.org.ala.bayesian.Observable;
import au.org.ala.bayesian.*;
import au.org.ala.names.lucene.LuceneLoadStore;
import au.org.ala.names.model.ExternalContext;
import au.org.ala.util.CleanedScientificName;
import au.org.ala.vocab.ALATerm;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.apache.commons.cli.*;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.StoredField;
import org.apache.lucene.document.StringField;
import org.apache.lucene.index.IndexableField;
import org.gbif.dwc.terms.DcTerm;
import org.gbif.dwc.terms.DwcTerm;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringWriter;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Build a name matching index.
 * <p>
 * The process of building an index is:
 * </p>
 * <ol>
 *     <li>Load all the source data into a loading index, so that we have a complete picture of the data.</li>
 *     <li>Annotate the loading index with inferred information - alternative names, parents, higher taxonomy, etc.</li>
 *     <li>Compute parameters for each calculation required by an inference class. The inference class and parameters are generated by the bayseian network compiler.</li>
 *     <li>Produce an output lucene index optimised for subsequent searching</li>
 * </ol>
 */
public class IndexBuilder implements Annotator {
    private static final Logger LOGGER = LoggerFactory.getLogger(IndexBuilder.class);

    /** The name of the property that gives the weight */
    public static final String WEIGHT_PROPERTY = "weight";
    /** The name of the property that gives the parent taxon */
    public static final String PARENT_PROPERTY = "parent";
    /** The name of the property that gives the parent taxon */
    public static final String ACCEPTED_PROPERTY = "accepted";
    /** The name of the property that gives the taxon id */
    public static final String TAXON_ID_PROPERTY = "taxonID";
    /** The name of the property that gives the scientifc name */
    public static final String SCIENTIFIC_NAME_PROPERTY = "scientificName";
    /** The name of the property that gives the scientifc name authorship */
    public static final String SCIENTIFIC_NAME_AUTHORSHIP_PROPERTY = "scientificNameAuthorship";
    /** The name of the property that gives the complete name+author */
    public static final String NAME_COMPLETE_PROPERTY = "nameComplete";
    /** The name of the property that gives the scientifc name */
    public static final String ALT_SCIENTIFIC_NAME_PROPERTY = "altScientificName";
    /** The name of the property that gives the scientifc name */
    public static final String COPY_PROPERTY = "copy";
    /** The date format for timestamping backups */
    public static final SimpleDateFormat BACKUP_TAG = new SimpleDateFormat("yyyyMMddHHmmss");
    /** The data format for timestamping metadata */
    public static final SimpleDateFormat TIMESTAMP = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");

    protected IndexBuilderConfiguration config;
    /** The network that this is a builder for */
    protected Network network;
    /** The builder to use in processing */
    protected Builder builder;
    /** The weight observable (required) */
    protected Observable weight;
    /** The parent observable (required) */
    protected Observable parent;
    /** The accepted name observable */
    protected Optional<Observable> accepted;
    /** The taxon ID observable (required) */
    protected Observable taxonId;
    /** The scientific name observable */
    protected Observable scientificName;
    /** The alternartive name observable */
    protected Optional<Observable> altScientificName;
    /** The scientific name authorship */
    protected Optional<Observable> scientificNameAuthorship;
    /** The complete, propertly formatted name/author pair */
    protected Optional<Observable> nameComplete;
    /** The annotation observable */
    protected Observable annotation;
    /** The set of terms to copy from an accepted taxon to a synonym */
    protected Set<Observable> synonymCopy;
    /** The set of fields to copy from an accepted taxon to a synonym */
    protected Set<String> synonymCopyFields;
    /** The load-store. Used to store semi-structured information before building the complete index. */
    protected LoadStore loadStore;

    /**
     * Construct with a configuration.
     *
     * @param config The configuration
     *
     * @throws StoreException if unable to create the load-store
     *
     */
    public IndexBuilder(IndexBuilderConfiguration config) throws BuilderException, StoreException, IOException {
        this.config = config;
        this.network = Network.read(this.config.getNetwork());
        this.builder = config.createBuilder(this);
        this.loadStore = config.createLoadStore(this);
        this.weight = this.network.findObservable(WEIGHT_PROPERTY, true).orElseThrow(() -> new BuilderException("Require observable " + WEIGHT_PROPERTY + ":true property"));
        this.parent = this.network.findObservable(PARENT_PROPERTY, true).orElseThrow(() -> new BuilderException("Require observable " + PARENT_PROPERTY + ":true property"));
        this.accepted = this.network.findObservable(ACCEPTED_PROPERTY, true);
        this.taxonId = this.network.findObservable(TAXON_ID_PROPERTY, true).orElseThrow(() -> new BuilderException("Require observable " + TAXON_ID_PROPERTY + ":true property"));
        this.scientificName = this.network.findObservable(SCIENTIFIC_NAME_PROPERTY, true).orElseThrow(() -> new BuilderException("Require observable " + SCIENTIFIC_NAME_PROPERTY + ":true property"));
        this.scientificNameAuthorship = this.network.findObservable(SCIENTIFIC_NAME_AUTHORSHIP_PROPERTY, true);
        this.nameComplete = this.network.findObservable(NAME_COMPLETE_PROPERTY, true);
        this.altScientificName = this.network.findObservable(ALT_SCIENTIFIC_NAME_PROPERTY, true);
        this.annotation = new Observable(this.getAnnodationField());
        this.annotation.setExternal(ExternalContext.LUCENE, this.getAnnodationField());
        this.synonymCopy = new HashSet<>(this.network.findObservables(COPY_PROPERTY, true));
        this.synonymCopyFields = this.synonymCopy.stream().map(observable -> observable.getField()).collect(Collectors.toSet());
    }

    /**
     * Load a source into the index builder.
     *
     * @param source The source to load
     *
     * @throws BuilderException if something foes wrong
     */
    public void load(Source source) throws BuilderException {
        source.load(this.loadStore);
    }

    /**
     * Build the index once the data has been loaded.
     * <p>
     * This builds all the information so that the index can be constructed.
     * It does not output the final index; see {@link #buildIndex(File)} for that.
     * </p>
     *
     * @throws BuilderException if unable to store information in the index
     * @throws InferenceException if unable to build the inference parameters
     */
    public void build() throws BuilderException, InferenceException {
        this.expandTree();
        this.expandSynonyms();
        this.buildParameters();
    }


    /**
     * Close down the index builder.
     * <p>
     *     This ensures that all underlying stores are gracefully shut down.
     * </p>
     *
     * @throws StoreException if unable to close
     */
    public void close() throws StoreException {
        this.loadStore.close();
    }

    /**
     * Traverse the tree, building a model of the taxonomic tree in terms of parent/child relationships
     * and fill out information about the
     *
     * @throws BuilderException if unable to traverse the tree
     */
    public void expandTree() throws BuilderException {
        LOGGER.info("Expanding accepted concept tree");
        int count = 0;
        int index = 1;
        Observation isRoot = new Observation(true, this.annotation, this.getAnnotationValue(ALATerm.isRoot));
        Iterable<Document> top = this.loadStore.getAll(DwcTerm.Taxon, isRoot);
        for (Document doc: top) {
            if (count++ % this.config.getLogInterval() == 0)
                LOGGER.info("Processing top-level document " + doc.get(this.taxonId.getField()));
            index = this.expandTree(doc, new LinkedList<Document>(), index);
            this.loadStore.commit();
        }
    }

    public int expandTree(Document document, Deque<Document> parents, int index) throws StoreException {
        int left = index;
        // Perform all derivations
        this.builder.expand(document, parents);
        String id = document.get(this.taxonId.getField());
        Set<String> allNames = new HashSet<>();
        Set<String> altNames = new HashSet<>();

        String name = document.get(this.scientificName.getField());
        CleanedScientificName n = new CleanedScientificName(name);
        allNames.add(n.getName());
        allNames.add(n.getBasic());
        allNames.add(n.getNormalised());
        // Ensure that the normalised version of the name is used.
        if (!name.equals(n.getNormalised())) {
            document.removeFields(this.scientificName.getField());
            document.add(new StringField(this.scientificName.getField(), n.getNormalised(), Field.Store.YES));
        }

        Optional<String> authorship = this.scientificNameAuthorship.map(sna -> document.get(sna.getField()));
        String nameComplete = this.nameComplete.map(nc -> document.get(nc.getField())).orElseGet(() -> (name + " " + authorship.orElse("")).trim());
        CleanedScientificName nc = new CleanedScientificName(nameComplete);
        allNames.add(nc.getName());
        allNames.add(nc.getBasic());
        allNames.add(nc.getNormalised());

        for (String nm : allNames) {
            document.add(new StringField(this.getNamesField(), nm, Field.Store.YES));
        }

        if (this.altScientificName.isPresent()) {
            if (this.accepted.isPresent()) {
                Iterable<Document> synonyms = this.loadStore.getAll(DwcTerm.Taxon, new Observation(true, this.accepted.get(), id));
                for (Document synonym : synonyms) {
                    String syn = synonym.get(this.scientificName.getField());
                    CleanedScientificName s = new CleanedScientificName(syn);
                    altNames.add(s.getName());
                    altNames.add(s.getBasic());
                    altNames.add(s.getNormalised());
                }
            }
            for (String nm : altNames) {
                document.add(new StringField(this.altScientificName.get().getField(), nm, Field.Store.YES));
            }
        }
        this.builder.infer(document);
        if (this.parent != null) {
            parents.push(document);
            Iterable<Document> children = this.loadStore.getAll(DwcTerm.Taxon, new Observation(true, this.parent, id));
            for (Document child : children) {
                index = this.expandTree(child, parents, index);
            }
            parents.pop();
        }
        this.setIndex(document, left, index);
        this.loadStore.update(document);
        return index + 1;
    }

    /**
     * Expand all synonyms, including parent taxonomy.
     *
     * @throws StoreException if unable to manage the updates
     */
    public void expandSynonyms() throws StoreException {
        LOGGER.info("Expanding synonyms");
        int count = 0;
        Observation isSynonym = new Observation(true, this.annotation, this.getAnnotationValue(ALATerm.isSynonym));
        Iterable<Document> synonyms = this.loadStore.getAll(DwcTerm.Taxon, isSynonym);
        for (Document doc: synonyms) {
            String id = doc.get(this.taxonId.getField());
            if (count++ % this.config.getLogInterval() == 0)
                LOGGER.info("Processing synonym " + id);
            Optional<String> aid = this.accepted.map(acc -> doc.get(acc.getField()));
            Optional<Document> acpt = Optional.empty();
            if (!aid.isPresent()) {
                LOGGER.error("Synonym document " + id + " does not have an accepted taxon id");
            } else {
                acpt = Optional.ofNullable(this.loadStore.get(DwcTerm.Taxon, this.taxonId, aid.get()));
                if (!acpt.isPresent()) {
                    LOGGER.error("Taxon " + id + " with accepted id " + aid + " does not have a matching accepted taxon");
                }
            }
            this.expandSynonym(doc, acpt);
        }
        this.loadStore.commit();
    }

    /**
     * Expand information about a synonym.
     * <p>
     * Unless otherwise specified, the synonym inherits information
     * such as the rank and higher taxonomy from the parent.
     * </p>
     *
     * @param document The synonym document
     * @param accepted The accepted taxon document
     *
     * @throws StoreException if unable to write the updated document
     */
    public void expandSynonym(Document document, Optional<Document> accepted) throws StoreException {
        Set<String> allNames = new HashSet<>();
        String name = document.get(this.scientificName.getField());
        CleanedScientificName n = new CleanedScientificName(name);
        allNames.add(n.getName());
        allNames.add(n.getBasic());
        allNames.add(n.getNormalised());
        // Ensure that the normalised version of the name is used.
        if (!name.equals(n.getNormalised())) {
            document.removeFields(this.scientificName.getField());
            document.add(new StringField(this.scientificName.getField(), n.getNormalised(), Field.Store.YES));
        }
        if (this.altScientificName.isPresent()) {
            for (String nm : allNames) {
                document.add(new StringField(this.altScientificName.get().getField(), nm, Field.Store.YES));
            }
        }
        if (accepted.isPresent()){
            Set<String> known = document.getFields().stream().map(f -> f.name()).collect(Collectors.toSet());
            for (String field : this.synonymCopyFields) {
                if (!known.contains(field)) {
                    for (IndexableField f : accepted.get().getFields(field))
                        document.add(f);
                }
            }
        }
        this.builder.infer(document);
        this.loadStore.update(document);
    }

    /**
     * Build the parameters for each taxon
     *
     * @throws StoreException
     * @throws InferenceException
     */
    public void buildParameters() throws StoreException, InferenceException {
        LOGGER.info("Building parameter sets");
        int count = 0;
        ParameterAnalyser<Document> analyser = this.loadStore.getParameterAnalyser(this.network, this.weight, this.config.getDefaultWeight());
        Iterable<Document> taxa = this.loadStore.getAll(DwcTerm.Taxon);
        for (Document doc : taxa) {
            String id = doc.get(this.taxonId.getField());
            if (count++ % this.config.getLogInterval() == 0)
                LOGGER.info("Processing parameters " + id);
            Parameters parameters = this.builder.createParameters();
            this.builder.calculate(parameters, analyser, doc);
            this.setParameters(doc, parameters);
            this.loadStore.update(doc);
        }
        this.loadStore.commit();

    }

    public void buildIndex(File output) throws StoreException, InferenceException {
        int count = 0;
        LOGGER.info("Building matchng index at " + output);
        if (output.exists()) {
            String backup = output.getName() + "-" + ((SimpleDateFormat) BACKUP_TAG.clone()).format(new Date());
            File dest = new File(output.getParent(), backup);
            output.renameTo(dest);
            LOGGER.info("Renamed existing " + output + " to " + dest);
         }
        if (!output.mkdirs())
            throw new IllegalArgumentException("Unable to create " + output);
        LoadStore index = new LuceneLoadStore(this, output, false);
        // Copy taxa across
        Iterable<Document> taxa = this.loadStore.getAll(DwcTerm.Taxon);
        for (Document doc : taxa) {
            index.update(doc);
        }
        // Insert metadata document
        Document metadata = this.createMetadata();
        index.store(metadata, ALATerm.Metadata);

        index.commit();
        index.close();
    }

    /**
     * Build a document describing the index
     *
     * @return The document metadata
     *
     * @throws StoreException if unable to construct the document
     */
    public Document createMetadata() throws StoreException {
        Document metadata = new Document();
        Observable creator = new Observable(DcTerm.creator);
        Observable created = new Observable(DcTerm.created);
        Observable description = new Observable(DcTerm.description);
        Observable identifier = new Observable(DcTerm.identifier);
        Observable title = new Observable(DcTerm.title);
        Observable source = new Observable(DcTerm.source);
        Observable builderClass = new Observable(ALATerm.builderClass);
        Observable version = new Observable(DcTerm.hasVersion);
        Date timestamp = new Date();
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
        mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        metadata.add(new StoredField(identifier.getField(), UUID.randomUUID().toString()));
        metadata.add(new StoredField(title.getField(), this.network.getId()));
        metadata.add(new StoredField(description.getField(), this.network.getDescription()));
        metadata.add(new StoredField(creator.getField(), System.getProperty("user.name", "unknown")));
        metadata.add(new StoredField(created.getField(), TIMESTAMP.format(timestamp)));
        metadata.add(new StoredField(builderClass.getField(), this.config.getBuilderClass().getName()));
        metadata.add(new StoredField(version.getField(), this.getClass().getPackage().getSpecificationVersion()));
        try {
            metadata.add(new StoredField(source.getField(), mapper.writeValueAsString(this.network)));
        } catch (JsonProcessingException ex) {
            throw new StoreException("Unable to write network condfiguration", ex);
        }
        return metadata;
    }

    /**
     * Annotate a document with additional information.
     * <p>
     * If the document does not have a parent or an accepted taxon
     * then annotate it as {@link ALATerm#isRoot}.
     * If the document does not have a parent but does have an accepted taxon,
     * then annotate it as {@link ALATerm#isSynonym}
     * </p>
     *
     * @param document The document
     * @throws StoreException If unable to create an annotation for some reason.
     */
    @Override
    public void annotate(Document document) throws StoreException {
        String p = document.get(this.parent.getField());
        String a = this.accepted.isPresent() ? document.get(this.accepted.get().getField()) : null;

        if (( p == null || p.isEmpty()) && (a == null || a.isEmpty()))
            this.annotate(document, ALATerm.isRoot);
        if ((p == null || p.isEmpty()) && (a != null && !a.isEmpty()))
            this.annotate(document, ALATerm.isSynonym);
    }

    /**
     * Run the index builder.
     * <p>
     * This is a generic, one-size-fits all builder.
     * You are better off using the generated builders that are associated with a specific
     * network configuration.
     * </p>
     *
     * @param args Command line arguments
     *
     * @throws Exception if unable to complete
     */
    public static void main(String[] args) throws Exception {
        Options options = new Options();
        Option configOption = Option.builder("c").longOpt("config").desc("Specify a configuration file").hasArg().argName("URL").type(URL.class).build();
        Option workOption = Option.builder("w").longOpt("work").desc("Working directory").hasArg().argName("DIR").type(File.class).build();
        Option networkOption = Option.builder("n").longOpt("network").desc("Network description").hasArg().argName("URL").type(URL.class).build();
        Option builderClassOption = Option.builder("b").longOpt("builder").desc("Network description").hasArg().argName("CLASS").type(Class.class).build();
        Option outputOption = Option.builder("o").longOpt("output").desc("Output index directory").hasArg().argName("DIR").type(File.class).build();
        Option helpOption = Option.builder("h").longOpt("help").desc("Print help").build();
        options.addOption(configOption);
        options.addOption(workOption);
        options.addOption(networkOption);
        options.addOption(builderClassOption);
        options.addOption(outputOption);
        options.addOption(helpOption);
        IndexBuilderConfiguration config;
        File output;

        CommandLineParser parser = new DefaultParser();
        CommandLine cmd = parser.parse(options, args);

        if (cmd.hasOption(helpOption.getOpt())) {
            HelpFormatter help = new HelpFormatter();
            help.printHelp("java -jar name-matching-builder [OPTIONS] [SOURCES]", options);
            System.exit(0);
        }
        if (cmd.hasOption(configOption.getOpt())) {
            config = IndexBuilderConfiguration.read(((URL) cmd.getParsedOptionValue(configOption.getOpt())));
        } else {
            config = new IndexBuilderConfiguration();
        }
        if (cmd.hasOption(workOption.getOpt())) {
            config.setWork((File) cmd.getParsedOptionValue(workOption.getOpt()));
        }
        if (cmd.hasOption(networkOption.getOpt())) {
            config.setNetwork((URL) cmd.getParsedOptionValue(networkOption.getOpt()));
        }
        if (cmd.hasOption(builderClassOption.getOpt())) {
            config.setBuilderClass((Class) cmd.getParsedOptionValue(builderClassOption.getOpt()));
        }
        if (cmd.hasOption(outputOption.getOpt())) {
            output = (File) cmd.getParsedOptionValue(outputOption.getOpt());
        } else {
            output = new File(config.getWork(), "output");
        }
        IndexBuilder builder = new IndexBuilder(config);
        for (String input: cmd.getArgs()) {
            File in = new File(input);
            Source source = null;
            if (!in.exists()) {
                System.err.println("Input file " + in + " does not exist");
                System.exit(1);
            }
            if (input.endsWith(".csv")) {
                source = new CSVSource(DwcTerm.Taxon, new FileReader(in));
            } else {
                System.err.println("Unable to determine the type of " + in);
            }
            builder.load(source);
        }
        builder.expandTree();
        builder.expandSynonyms();
        builder.buildParameters();
        builder.buildIndex(output);
        builder.close();
    }

}
