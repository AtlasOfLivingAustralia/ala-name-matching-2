package au.org.ala.bayesian.generated;

import au.org.ala.bayesian.BayesianException;
import au.org.ala.bayesian.Analyser;
import au.org.ala.bayesian.Classifier;
import au.org.ala.bayesian.Inference;
import au.org.ala.bayesian.Inferencer;
import au.org.ala.bayesian.Trace;
import au.org.ala.bayesian.Trace.TraceLevel;

public class Network3Inferencer_ implements Inferencer<Network3Classification> {
  public final static String SIGNATURE = "";

  public Network3Inferencer_() {
  }

  @Override
  public String getSignature() {
    return SIGNATURE;
  }

  public double infer_t(Network3Inferencer.Evidence evidence, Network3Parameters_ parameters, Trace trace) {
    double c$v1 = 1.0;
    double nc$v1 = 0.0;
    double c$v2 = evidence.isT$e$v2() ? 1.0 : 0.0;
    double nc$v2 = evidence.isF$e$v2() ? 1.0 : 0.0;
    double c$v3 = 0.0;
    double nc$v3 = 0.0;
    // Ignoring non-base v_2
    if (evidence.isT$e$v3()) {
       c$v3 += parameters.derived_v3_t$t_t * c$v1 * c$v2;
       c$v3 += parameters.derived_v3_t$t_f * c$v1 * nc$v2;
      if (trace != null) {
        String val_ = this.formatDouble(parameters.derived_v3_t$t_t) + " \u00b7 " + this.formatDouble(c$v1) + " \u00b7 " + this.formatDouble(c$v2) + " + " + this.formatDouble(parameters.derived_v3_t$t_f) + " \u00b7 " + this.formatDouble(c$v1) + " \u00b7 " + this.formatDouble(nc$v2);
        trace.add(TraceLevel.TRACE, "p(v_3) - v_3", "p(v_3 | v_1, v_2)·v_1·v_2 + p(v_3 | v_1, ¬v_2)·v_1·¬v_2", val_, c$v3);
      }
    }
    if (evidence.isF$e$v3()) {
      nc$v3 += parameters.derived_v3_f$t_t * c$v1 * c$v2;
      nc$v3 += parameters.derived_v3_f$t_f * c$v1 * nc$v2;
      if (trace != null) {
        String val_ = this.formatDouble(parameters.derived_v3_f$t_t) + " \u00b7 " + this.formatDouble(c$v1) + " \u00b7 " + this.formatDouble(c$v2) + " + " + this.formatDouble(parameters.derived_v3_f$t_f) + " \u00b7 " + this.formatDouble(c$v1) + " \u00b7 " + this.formatDouble(nc$v2);
        trace.add(TraceLevel.TRACE, "p(¬v_3) - !v_3", "p(¬v_3 | v_1, v_2)·v_1·v_2 + p(¬v_3 | v_1, ¬v_2)·v_1·¬v_2", val_, nc$v3);
      }
    }
    double result_ = (c$v3 + nc$v3);
    if (trace != null) {
      String val_ = "(" + this.formatDouble(c$v3) + " + " + this.formatDouble(nc$v3) + ")";
      trace.add(TraceLevel.TRACE, "c(E | v_1)", "(p(v_3) + p(¬v_3))", val_, result_);
    }
    return result_;
  }

  public double infer_f(Network3Inferencer.Evidence evidence, Network3Parameters_ parameters, Trace trace) {
    double c$v1 = 0.0;
    double nc$v1 = 1.0;
    double c$v2 = evidence.isT$e$v2() ? 1.0 : 0.0;
    double nc$v2 = evidence.isF$e$v2() ? 1.0 : 0.0;
    double c$v3 = 0.0;
    double nc$v3 = 0.0;
    // Ignoring non-base v_2
    if (evidence.isT$e$v3()) {
       c$v3 += parameters.derived_v3_t$f_t * nc$v1 * c$v2;
       c$v3 += parameters.derived_v3_t$f_f * nc$v1 * nc$v2;
      if (trace != null) {
        String val_ = this.formatDouble(parameters.derived_v3_t$f_t) + " \u00b7 " + this.formatDouble(nc$v1) + " \u00b7 " + this.formatDouble(c$v2) + " + " + this.formatDouble(parameters.derived_v3_t$f_f) + " \u00b7 " + this.formatDouble(nc$v1) + " \u00b7 " + this.formatDouble(nc$v2);
        trace.add(TraceLevel.TRACE, "p(v_3) - v_3", "p(v_3 | ¬v_1, v_2)·¬v_1·v_2 + p(v_3 | ¬v_1, ¬v_2)·¬v_1·¬v_2", val_, c$v3);
      }
    }
    if (evidence.isF$e$v3()) {
      nc$v3 += parameters.derived_v3_f$f_t * nc$v1 * c$v2;
      nc$v3 += parameters.derived_v3_f$f_f * nc$v1 * nc$v2;
      if (trace != null) {
        String val_ = this.formatDouble(parameters.derived_v3_f$f_t) + " \u00b7 " + this.formatDouble(nc$v1) + " \u00b7 " + this.formatDouble(c$v2) + " + " + this.formatDouble(parameters.derived_v3_f$f_f) + " \u00b7 " + this.formatDouble(nc$v1) + " \u00b7 " + this.formatDouble(nc$v2);
        trace.add(TraceLevel.TRACE, "p(¬v_3) - !v_3", "p(¬v_3 | ¬v_1, v_2)·¬v_1·v_2 + p(¬v_3 | ¬v_1, ¬v_2)·¬v_1·¬v_2", val_, nc$v3);
      }
    }
    double result_ = (c$v3 + nc$v3);
    if (trace != null) {
      String val_ = "(" + this.formatDouble(c$v3) + " + " + this.formatDouble(nc$v3) + ")";
      trace.add(TraceLevel.TRACE, "c(E | ¬v_1)", "(p(v_3) + p(¬v_3))", val_, result_);
    }
    return result_;
  }


  public Inference probability(Network3Inferencer.Evidence evidence, Network3Parameters_ parameters, Trace trace) {
    double c, p;
    double prior = parameters.prior_v1_t;
    double ph = 0.0;
    double pe = 0.0;

    if (trace != null)
        trace.push(TraceLevel.TRACE, "p(v_1)");
    try {
        if (evidence.isT$e$v1()) {
          c = this.infer_t(evidence, parameters, trace);
          p = c  * parameters.prior_v1_t;
          if (trace != null) {
            trace.value(TraceLevel.TRACE, "c(E | v_1)\u00b7p(v_1)", this.formatDouble(c) +  " \u00b7 " + this.formatDouble(parameters.prior_v1_t), p);
          }
          ph += p;
          pe += p;
        }
    } finally {
        if (trace != null)
            trace.pop(TraceLevel.TRACE);
    }
    if (trace != null)
        trace.push(TraceLevel.TRACE, "p(¬v_1)");
    try {
        if (evidence.isF$e$v1()) {
          c = this.infer_f(evidence, parameters, trace);
          p = c  * parameters.prior_v1_f;
          if (trace != null) {
            trace.value(TraceLevel.TRACE, "c(E | ¬v_1)\u00b7p(¬v_1)", this.formatDouble(c) +  " \u00b7 " + this.formatDouble(parameters.prior_v1_f), p);
          }
          pe += p;
        }
    } finally {
        if (trace != null)
            trace.pop(TraceLevel.TRACE);
    }
    return Inference.forPEH(prior, pe, ph);
  }

  @Override
  public Inference probability(Network3Classification classification, Classifier classifier, Trace trace) throws BayesianException {
    if (trace != null)
        trace.push(TraceLevel.TRACE, "inference");
    try {
        Network3Inferencer.Evidence evidence = classification.match(classifier);
        if (trace != null)
            trace.add(TraceLevel.TRACE, "evidence", evidence);
        Network3Parameters_ params = (Network3Parameters_) classifier.getCachedParameters();
        if (params == null) {
          params = new Network3Parameters_();
          classifier.loadParameters(params);
        }
        return this.probability(evidence, params, trace);
    } finally {
        if (trace != null)
            trace.pop(TraceLevel.TRACE);
    }
  }
}