package au.org.ala.bayesian.generated;

import au.org.ala.bayesian.BayesianException;
import au.org.ala.bayesian.Analyser;
import au.org.ala.bayesian.Classifier;
import au.org.ala.bayesian.Inference;
import au.org.ala.bayesian.Inferencer;
import au.org.ala.bayesian.Trace;

public class Network2Inferencer_ implements Inferencer<Network2Classification> {
  public final static String SIGNATURE = "";

  public Network2Inferencer_() {
  }

  @Override
  public String getSignature() {
    return SIGNATURE;
  }

  public double infer_t(Network2Inferencer.Evidence evidence, Network2Parameters_ parameters, Trace trace) {
    double c$v1 = 1.0;
    double nc$v1 = 0.0;
    double c$v2 = 0.0;
    double nc$v2 = 0.0;
    if (trace != null) {
        trace.add("v_1", c$v1);
        trace.add("!v_1", nc$v1);
    }
    if (evidence.isT$e$v2()) {
      c$v2 += parameters.inf_v2_t$t * c$v1;
    }
    if (evidence.isF$e$v2()) {
      nc$v2 += parameters.inf_v2_f$t * c$v1;
    }
    if (trace != null) {
        trace.add("v_2", c$v2);
        trace.add("!v_2", nc$v2);
    }
    return (c$v2 + nc$v2);
  }

  public double infer_f(Network2Inferencer.Evidence evidence, Network2Parameters_ parameters, Trace trace) {
    double c$v1 = 0.0;
    double nc$v1 = 1.0;
    double c$v2 = 0.0;
    double nc$v2 = 0.0;
    if (trace != null) {
        trace.add("v_1", c$v1);
        trace.add("!v_1", nc$v1);
    }
    if (evidence.isT$e$v2()) {
      c$v2 += parameters.inf_v2_t$f * nc$v1;
    }
    if (evidence.isF$e$v2()) {
      nc$v2 += parameters.inf_v2_f$f * nc$v1;
    }
    if (trace != null) {
        trace.add("v_2", c$v2);
        trace.add("!v_2", nc$v2);
    }
    return (c$v2 + nc$v2);
  }


  public Inference probability(Network2Inferencer.Evidence evidence, Network2Parameters_ parameters, Trace trace) {
    double p;
    double prior = parameters.prior_v1_t;
    double ph = 0.0;
    double pe = 0.0;

    if (trace != null)
        trace.push("t");
    try {
        if (evidence.isT$e$v1()) {
          p = this.infer_t(evidence, parameters, trace) * parameters.prior_v1_t;
          ph += p;
          pe += p;
        }
    } finally {
        if (trace != null)
            trace.pop();
    }
    if (trace != null)
        trace.push("f");
    try {
        if (evidence.isF$e$v1()) {
          p = this.infer_f(evidence, parameters, trace) * parameters.prior_v1_f;
          pe += p;
        }
    } finally {
        if (trace != null)
            trace.pop();
    }
    return Inference.forPEH(prior, pe, ph);
  }

  @Override
  public Inference probability(Network2Classification classification, Classifier classifier, Trace trace) throws BayesianException {
    if (trace != null)
        trace.push("inference");
    try {
        Network2Inferencer.Evidence evidence = classification.match(classifier);
        if (trace != null)
            trace.add("evidence", evidence);
        Network2Parameters_ params = (Network2Parameters_) classifier.getCachedParameters();
        if (params == null) {
          params = new Network2Parameters_();
          classifier.loadParameters(params);
        }
        return this.probability(evidence, params, trace);
    } finally {
        if (trace != null)
            trace.pop();
    }
  }
}